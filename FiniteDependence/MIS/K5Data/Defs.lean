import Mathlib

set_option maxRecDepth 200000
set_option maxHeartbeats 20000000

namespace FiniteDependence.MIS
namespace K5Data

inductive RhsDesc where
  | const
  | prev (w : String)
  | prod (m : Nat) (x : String) (n : Nat) (y : String)
  | u
deriving DecidableEq, Repr

structure StepData where
  Lprev : Nat
  n : Nat
  A0_entries : Array (Nat × Nat)
  A0_entries_chunks : Array (Array (Nat × Nat)) := #[]
  inv_entries : Array (Nat × Nat × ℚ)
  inv_entries_chunks : Array (Array (Nat × Nat × ℚ)) := #[]
  rhs : Array RhsDesc
  rhs_chunks : Array (Array RhsDesc) := #[]
deriving Repr

structure ResidRowData where
  Lprev : Nat
  cols : Array Nat
  rhs : RhsDesc
deriving Repr

def extensions (w : String) : List String :=
  match w.toList.reverse with
  | '1' :: _ => [w.push '0']
  | '0' :: '0' :: _ => [w.push '1']
  | _ => [w.push '0', w.push '1']

def extendWords (words : Array String) : Array String :=
  (words.toList.flatMap extensions).toArray

/--
The allowed State words of length `L` over `{0,1}` (forbid `11` and `000`), in a deterministic order.

This is generated by iterating the one-step extension rule `L-1` times starting from `["0","1"]`.
-/
def allowedWords (L : Nat) : Array String :=
  if L = 0 then
    #[]
  else
    Nat.iterate extendWords (L - 1) #["0", "1"]

end K5Data
end FiniteDependence.MIS
